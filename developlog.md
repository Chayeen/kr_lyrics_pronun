# 2018-03-22 22:09:54 最初的考虑
把韩语解析的python代码写出来（先实现一个基础版本，基于养乐多的基础发音教程，实现最基本的韩文字发音转换；后面再根据各种音变规则写一个存在音变的版本；如果能够识别韩语音乐发音，根据idol发音进行具体调整就更好了）：参考[python实现韩文分解](http://blog.csdn.net/u011289327/article/details/44618931)、[python爬取网易云音乐我的歌单歌词](https://www.jianshu.com/p/c0ae445023a2?from=timeline)[python爬歌词](https://www.cnblogs.com/Beyond-Ricky/p/6757954.html)、[韩语语音识别现状](http://www.wanjishu.com/p/qy073T170802.html)在语言学中，韩语属于黏着语，其自然词汇由大量词素聚集构成，同时语言具有丰富的音韵变化。黏着语是语言形态学中的一个语言类别，这一类别的语言需要大量依靠词素的屈折变化来表现文法关系。第一个主要是语言模型方面，韩语的自然语言单元是由空格分割开的字和词，长度不固定，有可能是实体词加助词，也可能是单独的实体词，对应于英语中的几个单词。第二个挑战是声学模型建模，黏着特性导致严重的协同发音，从而使声学模型的混淆度大大提升。解决方案，可以通过引入同位音素的概念来削弱声学模型的混淆程度，但实验证明这一方法尽管在单音子（monophone）声学模型建模单元上效果较为显著，但在常规语音识别系统所使用的三音子（triphone）声学模型建模单元上效果并不理想。如果按照书写方式来分，在韩语中共有首辅音19 种，元音21种，尾辅音27种。由于韵尾可以省略，因此韵尾共有28 种形式，由此可以推算出谚文数量为19×21×28=__11172__个。就发音而言，每种首辅音和元音都有其独特的发音，但是首辅音o为不发声辅音，而27 种韵尾则被归结为7组，每组中所有的尾辅音都与一个特定的首辅音发音相同。同时考虑到不含韵尾的情况，朝鲜语音节数量共计19×21×8=__3192__。韩语词汇在句中以空格分隔，其由若干谚文构成，谚文数量可以是一个或者多个。可以根据谚文字形简便获得其unicode编码。可以通过韩文的unicode编码反推罗马读音，加上一些韩文的变音规则，在资源极度缺乏的时候，可以用来自动生成韩语的声学训练语料，从unicode编码反推罗马读音的代码。base = 44032、df = int(integers[iElement]) - base、iONS = int(math.floor(df / 588)) + 1、iNUC = int(math.floor((df % 588) / 28)) + 1、iCOD = int((df % 588) % 28) + 1。鉴于这种统一的发音方式，先前的研究者通常将相同的发音首辅音和尾音归为同一音素，此种方法韩语音素集按照理论发音构建，包含18个首辅音、21个元音和1个尾辅音，共计40个音素。大多数时候，韩语的训练语料非常有限，又由于韩语是音形字，所以有很多学者研究从韩语形态学分析发音，自动生成训练的语音。[网易云音乐 歌词制作软件 BesLyric](http://www.cnblogs.com/BensonLaur/p/6262565.html)这个好厉害。——重新整理一下需求：想要一个批量韩语歌词发音生成的代码；首先批量的韩语歌词，通过爬取网易云音乐的歌词，每个歌词保存一个歌词文件；然后读取歌词文件中的韩文，批量输出发音（这里有几个问题，基础发音中，k/g b/p t/d s/x c/j c/q各种多音，主要是前三个不好判断；其次，如果存在音变现象，简单的音变还可以，比如说一些连音化，复杂一点的什么鼻音化、紧音化就不是很了解了；最后，有些处理是看心情的，不管怎么处理都可以，这时候就要与原音进行对比，找到最相似的音频了）；如果要和原音做对比再进行输出的话，首先就要对原音进行人声分离，还要对韩文字的几种发音处理情况进行发音，然后与分离出来的人声作对比，找到最相似的那一组发音，感觉就是在做语音识别的活（如果能够自动生成歌词就更好了，通过播放音乐，识别音乐中的人声歌词，并且根据时间，自动制作歌词时间轴）

# 2018-03-22 22:11:00
今天晚上先把 python 爬取网易云歌单歌词的代码搞定，参考
[python爬取网易云音乐我的歌单歌词](https://www.jianshu.com/p/c0ae445023a2?from=timeline)
[python爬歌词](https://www.cnblogs.com/Beyond-Ricky/p/6757954.html)

# 2018-03-22 22:45:42
1. 刚刚修改缩进，本来准备直接运行，又弄了下github在chayeen这台服务器上的账号，直接把之前本地建立的私钥copy过去不能用，原因是权限太高，按照网上说的降低权限到0600就可以用了`chmod 0600 /root/.ssh/id_rsa`命令。——现在应该就可以直接从服务器提交到远程github上了，密钥使用还是有密码，照常。
2. 然后修改了下代码的url，改成自己的歌单试试看：http://music.163.com/#/playlist?id=614151599
- 遇到没有requests库的问题，直接pip3 install 安装一下就可以了。

> [root@iz2ze8e1dj06n0wjqj19n2z kr_lyrics_pronun]# python3 crawllyrics.py 
> Traceback (most recent call last):
>   File "crawllyrics.py", line 3, in <module>
>     import requests
> ImportError: No module named 'requests'
> [root@iz2ze8e1dj06n0wjqj19n2z kr_lyrics_pronun]# pip3 install requests

- 又遇到没有 bs4 的问题照样安装就可以了

> [root@iz2ze8e1dj06n0wjqj19n2z kr_lyrics_pronun]# python3 crawllyrics.py 
> Traceback (most recent call last):
>   File "crawllyrics.py", line 6, in <module>
>     from bs4 import *
> ImportError: No module named 'bs4'
> [root@iz2ze8e1dj06n0wjqj19n2z kr_lyrics_pronun]# pip3 install beautifulsoup4
    
- 莫名其妙的错误：

> [root@iz2ze8e1dj06n0wjqj19n2z kr_lyrics_pronun]# python3 crawllyrics.py 
> /usr/lib/python3.4/site-packages/bs4/__init__.py:181: UserWarning: No parser was explicitly specified, so I'm using the best available HTML parser for this system ("html.parser"). This usually isn't a problem, but if you run this code on another system, or in a different virtual environment, it may use a different parser and behave differently.
> 
> The code that caused this warning is on line 24 of the file crawllyrics.py. To get rid of this warning, change code that looks like this:
> 
>  BeautifulSoup(YOUR_MARKUP})
> 
> to this:
> 
>  BeautifulSoup(YOUR_MARKUP, "html.parser")
> 
>   markup_type=markup_type))
> Traceback (most recent call last):
>   File "crawllyrics.py", line 30, in <module>
>     song_id = item('a')[0].get("href",None)
> TypeError: 'NavigableString' object is not callable

- 改了下第24行，再试试：

> [root@iz2ze8e1dj06n0wjqj19n2z kr_lyrics_pronun]# python3 crawllyrics.py 
> Traceback (most recent call last):
>   File "crawllyrics.py", line 30, in <module>
>     song_id = item('a')[0].get("href",None)
> TypeError: 'NavigableString' object is not callable

- 没有之前的提示了，但是还是有error
2018-03-22 23:21:57，卡住了，这个应该是bs4这个python包不太会用的缘故，而且感觉他的解析也有点问题，估计网易云对网页进行了一些修改，考虑考虑重新弄一下，有点难度。

# 2018-03-26 22:39:25
晚上重新各种搜了下,发现是最开始使用的url不对,在网易云音乐中所有的链接都要把 '#' 删掉才行，否则获取的URL是假链接。改了之后就可以l了。
刚刚简单修改了下，让所有的歌词文件分歌曲题目放在了lyrics文件夹中。刚刚遇到了一个bug在标题中有空格&其他特殊字符，"我有一个道姑朋友（……）"这首歌就没有正常存入，不过考虑到本来就是弄韩语的，所以直接把这个bug忽视掉了，存了3个歌单的韩语歌，随便打开了个看了下，还是不错，格式可能需要微调，不调也行。可以进行下一步了

# 2018-03-26 22:50:11
下一个功能就是，把韩语文字标上发音。
参考[python实现韩文分解](http://blog.csdn.net/u011289327/article/details/44618931)

直接copy了个代码，出了点问题：
UnicodeError: UTF-16 stream does not start with BOM

2018-03-26 23:47:18，问题解决了，因为原始文件是utf-8格式的，而代码里是utf-16格式的，全部改成utf-8就好了。
现在已经能够直接输出所有拼音了，不过不包含音变情况。争取明天能够添加上连音的情况。而且现在收音部分的发音还有点点问题，主要是双收音的发音问题，以及结合后面的音变问题。

# 2018-03-27 09:48:03
刚刚吃早餐的时候想了下，因为从韩语文字到韩语发音存在ㅇ安静音的情况，也就是说，如果从转化后的发音来看音变的话，不合理，所以现在的想法是，先根据韩语文字，把音变规则给搞定，搞定之后仍然是韩语文字，也就是说，需要先把韩文字进行拆分（已经实现），拆分后根据音变规则，再进行合并，合并之后输出 "[]" 这样的韩文字音标，再根据这种韩文字音标使用现在的转化机制——另外刚刚感觉有个bug，如果有非韩文字出现在韩文字之前，这些字没有进行输出——2018-03-27 09:59:45，刚刚看了下代码，修复了。

# 2018-03-27 09:59:54
又想了下，其实从拼音也能看出来，不过信息量会复杂一些，还是选择先转化成韩文字音标好了。

另外还有一件事，其实除了前轻后重以外，有3个包含()的音其实能够确定与那些文字进行搭配的时候有什么发音——其实，是不是直接对每个韩文字把它的发音都存起来，然后之后就可以直接对照就行了？——即，遍历所有韩文字，输出所有韩文字的发音，其实也就3000+，存到一个 hash or dic 里，直接查表就行了。

# 2018-03-27 10:18:24
刚刚又优化了一点格式上的bug，现在转化基本上没有问题了。难点还是落在了发音规则怎么弄了。——先不考虑隔写的影响，所有隔写的都不进行连音化，这样就按照隔写可以对原句进行分割。

# 2018-03-27 10:21:00 参照之前整理的规则，转化成程序员能够理解的伪代码实现

# vowels and consonants
first_parts = ("ㄱ", "ㄲ", "ㄴ", "ㄷ", "ㄸ", "ㄹ", "ㅁ", "ㅂ", "ㅃ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅉ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ")  
third_parts = ("", "ㄱ", "ㄲ", "ㄳ", "ㄴ", "ㄵ", "ㄶ", "ㄷ", "ㄹ", "ㄺ", "ㄻ", "ㄼ", "ㄽ", "ㄾ", "ㄿ", "ㅀ", "ㅁ", "ㅂ", "ㅄ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ")  

1. 连音化：
    - 单收音：前一个字除（ㅇㅎ）外的所有收音，后一个字辅音为ㅇ，辅音挪动到元音进行发音：third_parts = ("", __"ㄱ"__, "ㄲ", "ㄳ", __"ㄴ"__, "ㄵ", "ㄶ", __"ㄷ"__, __"ㄹ"__, "ㄺ", "ㄻ", "ㄼ", "ㄽ", "ㄾ", "ㄿ", "ㅀ", __"ㅁ"__, __"ㅂ"__, "ㅄ", __"ㅅ"__, "ㅆ", "ㅇ", __"ㅈ"__, __"ㅊ"__, __"ㅋ"__, __"ㅌ"__, __"ㅍ"__, "ㅎ")  ：也就是说，如果检测到了"ㄱ/ㄴ/ㄷ/ㄹ/ㅁ/ㅂ/ㅅ/ㅈ/ㅊ/ㅋ/ㅌ/ㅍ|ㅇ"这种模式（"|"表示是两字之间），就可以直接转换成"|ㄱ/ㄴ/ㄷ/ㄹ/ㅁ/ㅂ/ㅅ/ㅈ/ㅊ/ㅋ/ㅌ/ㅍ"这种模式（ㅇ没有了），然后再根据"|"把字进行组合，就可以得到音标了。
    - 双收音：前一个字为双收音，后一个字辅音为ㅇ，一般左边留下，后边收音连过去：也就是说，如果检测到了"ㄲ/ㄳ/ㄵ/ㄶ/ㄺ/ㄻ/ㄼ/ㄽ/ㄾ/ㄿ/ㅀ/ㅄ/ㅆ|ㅇ"的模式（这里有个问题，需要把双收音拆分成单收音的组合）——2018-03-27 10:43:48，刚刚想到，其实可以考虑使用正则模式匹配然后替换的方式来做这种音变现象的转换。——大多数情况下，直接会转化成"ㄱㄱ/ㄴㅈ/ㄹㄱ/ㄹㅁ/ㄹㅂ/ㄹㅌ/ㄹㅍ|ㅇ"，这个时候直接使用第一个单收音的规则，就可以直接进行替换了；"ㅎ/ㄶ/ㅀ|ㅇ"这个是ㅎ的脱落现象，如果出现这样的模式，则直接替换成"/ㄴ/ㄹ|ㅇ"，然后再使用第一个单收音的规则；而如果双收音右边是ㅅ，则需要进行紧音化，即"ㄳ/ㄽ/ㅆ/ㅄ|ㅇ"变成"ㄱㅆ/ㄹㅆ/ㅅㅆ/ㅂㅆ|ㅇ"，这里不能直接使用第一个单收音的规则，而是直接紧音化变成"ㄱ/ㄹ/ㅅ/ㅂ|ㅆㅇ"——2018-03-27 10:56:01总的来说，单收音的连音化是最后检查的部分，ㅎ的脱落要在它之前。
    - ㅎ的非标准连音：前一个字收音为"ㄴ/ㄹ/ㅁ"，后一个字辅音为ㅎ时，发生类似连音的变化，并没有规定，两种发音都可以，不过大多数时候都会发生连音——[可选规则]，即"ㄴ/ㄹ/ㅁ|ㅎ"时，变成"|ㄴ/ㄹ/ㅁ"——这里可以后面送气化进行结合
    - 连音选择：——这里可能会造成一定的错误，再说
        + 隔写的选择：现在只要隔写，就不进行连音化，也就是说，连音化只在空格间隔的单词内部进行
        + 本音与代表音的选择：发生音变的两个字，如果不可分割，用本音；可分割，用代表音——结合上面隔写，直接就 __全部用本音__连，既然词都写在一起了，用本音连正确的可能性更大，上面的规则也不用变化，都是用本音连的。
2. 鼻音化：
    - 收音鼻音化：前一个字收音为ㄱㄷㅂ（包括代表音），后一个字辅音为鼻音ㄴㅁ，ㄱㄷㅂ被ㄴㅁ同化，分别变为鼻音ㅇㄴㅁ，即"ㄱ/ㅋ/ㄲ/ㄺ/ㄳ|ㄴ/ㅁ"变成"ㅇ|ㄴ/ㅁ"，"ㄷ/ㅌ/ㅅ/ㅈ/ㅊ/ㅆ/ㅎ|ㄴ/ㅁ"变成"ㄴ|ㄴ/ㅁ"，"ㅂ/ㅍ/ㅄ/ㄿ|ㄴ/ㅁ"变成"ㅁ|ㄴ/ㅁ"
    - 辅音鼻音化：汉字词中，前一个收音是鼻音ㅇㅁ，后一个字的辅音是ㄹ时，ㄹ被ㅇㅁ同化，变为鼻音ㄴ——[可选规则]，即"ㅇ/ㅁ|ㄹ"变成"ㅇ/ㅁ|ㄴ"（这里主要的问题是不知道怎么判断是汉字词）
    - 收辅音鼻音化：汉字词中，前一个字的收音是ㄱㅂ（汉字词中没有收音是ㄷ的情况），后一个字的辅音是ㄹ时，ㄹ受ㄱㅂ影响，按照上述规则2变为鼻音ㄴ，ㄱㅂ受到ㄴ的影响，又按照上述规则1，分别变为ㅇㅁ——[可选规则]，即"ㄱ/ㅂ|ㄹ"->"ㄱ/ㅂ|ㄴ"->"ㅇ/ㅁ|ㄴ"，即"ㄱ|ㄹ"变成"ㅇ|ㄴ"，"ㅂ|ㄹ"变成"ㅁ|ㄴ"
3. 紧音化：
    - 阻塞音：前一个字收音按阻塞音ㄱㄷㅂ（不包括ㅎ）发音（包括代表音，需要注意ㄼ大多数时候读ㄹ但是也有读ㅂ的时候，就要发生紧音化），会造成后面相连的辅音ㄱㄷㅂㅅㅈ发生紧音化：即"ㄱ/ㅋ/ㄲ/ㄺ/ㄳ/ㄷ/ㅌ/ㅅ/ㅈ/ㅊ/ㅆ/ㅂ/ㅍ/ㅄ/ㄿ|ㄱ/ㄷ/ㅂ/ㅅ/ㅈ"->"ㄱ/ㅋ/ㄲ/ㄺ/ㄳ/ㄷ/ㅌ/ㅅ/ㅈ/ㅊ/ㅆ/ㅂ/ㅍ/ㅄ/ㄿ|ㄲ/ㄸ/ㅃ/ㅆ/ㅉ"
    - 词干ㄴㅁ：动词、形容词词干的最后一个字收音按ㄴㅁ发音（不包括ㄶ，它会造成其他音变），会造成后面相连的词尾（大多数情况下词干还是直接接的词尾，不过也有接助词的情况）的辅音ㄱㄷㅅㅈ发生紧音化：[可选规则]，即"ㄴ/ㄵ/ㅁ/ㄻ|ㄱ/ㄷ/ㅅ/ㅈ"->"ㄴ/ㄵ/ㅁ/ㄻ|ㄲ/ㄸ/ㅆ/ㅉ"
    - 汉字词ㄹ：汉字词中，一般（不是所有）前一个字的收音是ㄹ时，会造成后面相连的辅音ㄷㅅㅈ发生紧音化，同字相叠而不受此影响：[可选规则]，即"ㄹ|ㄷ/ㅅ/ㅈ"->"ㄹ|/ㄸ/ㅆ/ㅉ"
    - 合成词：在一部分合成词（如果是两个词合成出来构成了一个新的词）及派生词（如果是加上前缀or后缀构成的词），两个部分链接的位置会发生紧音化——完全不清楚哪些是合成词or派生词了，放弃这条规则
    - ㄹ词尾：定语词尾ㄹ/을及其他以ㄹ/을开始的词尾会造成后面的ㄱㄷㅂㅅㅈ发生紧音化：[可选规则]，"ㄹ/을|ㄱ/ㄷ/ㅂ/ㅅ/ㅈ"->"ㄹ/을|ㄲ/ㄸ/ㅃ/ㅆ/ㅉ"
    - ㄹ双收音：词干最后一个字的收音是ㄼㄾ（双收音按照ㄹ读，没有ㅀ）时，会造成后面词尾的辅音ㄱㄷㅅㅈ发生紧音化（没有ㅂ的词尾）：[可选规则]，"ㄼ/ㄾ|ㄱ/ㄷ/ㅅ/ㅈ"->"ㄼ/ㄾ|ㄲ/ㄸ/ㅆ/ㅉ"
    - ㅎㅅ相遇：前一个字的收音是ㅎㄶㅀ时，ㅎ的部分与后一个字的辅音ㅅ合并，变成紧音ㅆ：[必需规则]，"ㅎ/ㄶ/ㅀ|ㅅ"->"ㅎ/ㄶ/ㅀ|ㅆ"
    - 其他：双收音中ㅅ向后连音时，按照紧音去读（없어요[업써요]）——写在连音化部分了；部分外来语中的紧音处理，韩语中对外来语的标记有规定，但是读音没有规定，具有一定随意性（돈가스）——不管；数词여덟 열 스물的紧音处理，经常和后面的词连在一起发生紧音化，规定没有——也不管。
4. 颚音化%送气化：
    - 颚音化：前一个字的收音是ㄷㅌ，与后面相连的助词或词缀（包括이다-表示是的）中的ㅣ结合时，分别按照ㅈㅊ进行连音：[可选规则]："ㄷ/ㅌ|ㅇㅣ "->"|ㅈ/ㅊㅣ "（连音化的特殊形式，需要能够区分助词or词缀，不然就把两种输出都弄出来选）
    - ㅎ在前送气化：前一个字的收音是ㅎㄶㅀ时，ㅎ的部分与后一个字的辅音ㄱㄷㅈ合并，变成ㅋㅌㅊ：[必需规则]，"ㅎ/ㄶ/ㅀ|ㄱ/ㄷ/ㅈ"->"ㅎ/ㄶ/ㅀ|ㅋ/ㅌ/ㅊ"
    - ㅎ在后送气化：与上一个规则顺序相反，收音中的ㄱㄷㅂ（包括双收音）与后一个字的辅音ㅎ相遇时，发生送气化，并分别变成ㅋㅌㅍ，包括代表音为ㄷ的ㅅㅈㅊㅌ：[必需规则]，"ㄱ/ㄲ/ㄺ/ㄳ/ㄷ/ㅅ/ㅈ/ㅊ/ㅌ/ㅂ/ㅄ/ㄿ|ㅎ"->"ㅋ/ㅋ/ㅋ/ㅋ/ㅌ/ㅌ/ㅌ/ㅌ/ㅌ/ㅍ/ㅍ/ㅍ|ㅎ"——接助词需要先变成代表音再进行送气化
    - 颚音化&送气化：当收音ㄷ与词缀히结合时，先根据送气化规则变成[티]，再按照颚音化变成[치]：[可选规则]："ㄷ|ㅎㅣ "->"ㅌ|ㅎㅣ"->"|ㅊㅣ"
5. 边音化&添加音

# 2018-03-27 13:30:33
整体来说的话，涉及到语法词汇的规则都是可选规则，即可能变可能不变的那种，输出两种可能性，由用户决定使用哪一种。如果没有音变or没有这种不确定性的，就直接输出（唯一的变化可能是隔写的影响了）

# 2018-03-27 13:33:17
感觉有些规则，特别是紧音化的规则，有些笔记记得还不是特别好。

# 2018-03-27 13:34:27
上午弄到现在，基本上把音变的规则梳理了一遍，准备用正则的方式，先把一句话拆分成韩文字字节的格式，然后再根据模式匹配规则，进行替换，替换完了之后，再把韩文字拼接起来，输出韩文字音标格式，然后再使用转换的代码，输出最后的发音。
另外，准备把所有文字和发音都输出出来，然后进行查表；又需要考虑发音中的前轻后重的现象，可能可以选择比较好的k/g,b/p,t/d的格式。
另外，感觉音变的视频还需要再好好看看，有些笔记做得不是很好
另外，感觉语法和词汇可以再加把劲，可能可以把语法也考虑进去。
# 2018-03-27 16:29:37
刚刚把《20090729》的歌词按照发音写了一版，边听边弄，基本上还是能搞定？可能还是有一些不太好的地方，emmm，可能是所谓的添加音之类的，anyway，反正发了一个，争取每天晚上回去弄一个吧

# 2018-03-27 17:26:12
刚刚又整理了一些，现在有217首歌，不过应该有比较多的重复版本，真正的无重复可能差不多160篇，每天一个，不能多，嗯，剩下的时间就给代码优化以及语法学习。

# 2018-04-09 22:20:50
今天在实验室优化了送气化的代码，另外感觉不太想把韩文字音标输出出来，还是直接只输出罗马音标比较好。
之前还找到了一个把网易云音乐的缓存文件转换成mp3文件的程序，可以考虑用python对音频文件进行语音识别——韩语语音识别——能够输出一些音频和文字对应的语料库，可能可以做到直接语音识别韩文字。
另外还想做解析韩文字，文字翻译or语法翻译的程序——感觉是要实现一个韩语翻译器的感觉——其实主要是想要输入一段歌词，能够把歌词中涉及到的韩语单词输出出来，背诵，可能要结合NAVER进行。

# 2018-04-09 23:01:43
[这个貌似是NAVER的官方开发说明文档](https://developers.naver.com/docs/labs/translator/)：遗憾的是你妹的是韩语，有点看不懂，虽然有代码，感觉貌似是通过post请求，返回json格式的字符串来做的，先作为参考吧
[一个naver翻译的包，是Haskell语言的](https://hackage.haskell.org/package/naver-translate)：举的例子用的是汉语翻译成日语，不确定是否能够翻译成中文，这里是github的[源码](https://github.com/dahlia/naver-translate)
[又一个github上的代码](https://github.com/pjc0247/NaverTranslator)：但是只有一个RADEME.md，感觉是写的Java，感觉可以参考一下代码，写个python版本的。
[又一个node.js的版本](https://www.npmjs.com/package/naver-translator)：真的可以考虑写个python的了。
```java
NaverTranslator

NAVER TRANSLATE API INTERFACE w/ StrongHTTP

// [Service("v1/language")]
public interface TranslateAPIInterface : WithCommonHeader
{
    [Post, Resource("translate")]
    [JsonPath("message.result.translatedText")]
    Task<string> Translate(
        [RequestUri]string source, [RequestUri]string target,
        [RequestUri]string text);
}

public class TranslateAPI
{
    public static TranslateAPIInterface Create(string clientId, string clientSecret)
    {
        var api = RemotePoint.Create<TranslateAPIInterface>("https://openapi.naver.com");

        api.commonHeaders = new Dictionary<string, string>()
        {
            ["X-Naver-Client-Id"] = clientId,
            ["X-Naver-Client-Secret"] = clientSecret
        };

        return api;
    }
}
public class TargetLanguages
{
    public static readonly string Korean = "ko";
    public static readonly string English = "en";
    public static readonly string Chinese = "zh-CN";
    public static readonly string Japanese = "ja";
}
Usage

var tr = TranslateAPI.Create("CLIENT_ID", "CLIENT_SECRET");

var translated = await tr.Translate(
    TargetLanguages.Korean, TargetLanguages.English,
    "안녕");
```
# 2018-04-09 23:13:28
现在还有的比较关键的问题就是，用naver可以翻译整个句子，不过如果想要对一句话里面的单词进行输出，可能需要一个一个单独进行查询，实在不行就直接按照空格进行隔断好了。